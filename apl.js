Steven J.


apl


Drive
Search results
NEW 
Folders and views
My Drive
Shared with me
Google Photos
Recent
Starred
Trash
9 GB of 15 GB used
Upgrade storage
Earlier this year
Name
Owner
Last modified
File size

p189-halasz.pdf
me
Feb 23, 2016me
1 MB
Older
Name
Owner
Last modified
File size

Paris, Ohio
me
Sep 3, 2015me
—

Halasz%2c Steven FINAL FORMAT 050514VC.doc
me
Jun 26, 2015me
29 KB

Expenses 2014.xlsx
me
Apr 30, 2015me
45 KB

PNC 2014-10.pdf
me
Dec 27, 2014me
215 KB

PNC 2014-09.pdf
me
Dec 27, 2014me
215 KB

PNC 2014-07.pdf
me
Dec 27, 2014me
216 KB

PNC 2014-06.pdf
me
Dec 27, 2014me
218 KB

PNC 2014-05.pdf
me
Dec 27, 2014me
216 KB

PNC 2014-03.pdf
me
Dec 27, 2014me
215 KB

PNC 2014-02.pdf
me
Dec 27, 2014me
214 KB

PNC 2014-01.pdf
me
Dec 27, 2014me
214 KB

PNC 2013-12.pdf
me
Dec 27, 2014me
215 KB

PNC 2013-11.pdf
me
Dec 27, 2014me
217 KB

PNC 2013-10.pdf
me
Dec 27, 2014me
217 KB

PNC 2013-09.pdf
me
Dec 27, 2014me
217 KB

PNC 2013-08.pdf
me
Dec 27, 2014me
218 KB

PNC 2013-07.pdf
me
Dec 27, 2014me
219 KB

PNC 2013-06.pdf
me
Dec 27, 2014me
220 KB

PNC 2013-05.pdf
me
Dec 27, 2014me
216 KB

PNC 2013-04.pdf
me
Dec 27, 2014me
217 KB

PNC 2013-01.pdf
me
Dec 27, 2014me
219 KB

PNC 2012-12.pdf
me
Dec 27, 2014me
218 KB

PNC 2012-11.pdf
me
Dec 27, 2014me
217 KB

PNC 2012-10.pdf
me
Dec 27, 2014me
219 KB

PNC 2012-09.pdf
me
Dec 27, 2014me
217 KB

PNC 2012-08.pdf
me
Dec 27, 2014me
220 KB

PNC 2012-07.pdf
me
Dec 27, 2014me
215 KB

PNC 2012-06.pdf
me
Dec 27, 2014me
221 KB

PNC 2012-04.pdf
me
Dec 27, 2014me
216 KB

PNC 2011-10.pdf
me
Dec 27, 2014me
217 KB

PNC 2011-08.pdf
me
Dec 27, 2014me
215 KB

PNC 2011-07.pdf
me
Dec 27, 2014me
216 KB

PNC 2011-06.pdf
me
Dec 27, 2014me
214 KB

PNC 2011-02.pdf
me
Dec 27, 2014me
214 KB

PNC 2011.03.pdf
me
Dec 27, 2014me
215 KB

PNC 2010-12.pdf
me
Dec 27, 2014me
216 KB

PNC 2010-11.pdf
me
Dec 27, 2014me
214 KB

PNC 2010-10.pdf
me
Dec 27, 2014me
217 KB

PNC 2010-09.pdf
me
Dec 27, 2014me
215 KB

Kontodetails 2013 FPL.xls
me
Nov 1, 2014me
222 KB

Kontodetails 2013 FPL.xls
me
Oct 26, 2014me
222 KB

Halasz%2c Steven FINAL FORMAT 050514VC.doc
me
May 9, 2014me
29 KB

steven-halasz-right-management-2014-03-21.pdf
me
Mar 21, 2014me
101 KB

Annual GPS 2013
me
Feb 25, 2014me
—

Annual GPS 2013.pdf
me
Feb 25, 2014me
94 KB

PNC Statement Sept 2013.pdf
me
Oct 8, 2013me
217 KB

Fiserv 2012 Annual Review.pdf
me
Feb 13, 2013me
85 KB

US3953032.pdf
me
Oct 16, 2012me
176 KB

apl.js
me
Jun 29, 2012me
64 KB

apl.js
me
Jun 28, 2012me
64 KB

apl.js
me
Jun 27, 2012me
64 KB

apl.js
me
Jun 26, 2012me
64 KB

apl.js
me
Jun 25, 2012me
64 KB

apl.js
me
Jun 21, 2012me
61 KB

APL.cs
me
May 11, 2012me
205 KB

ToDo.txt
me
May 11, 2012me
1 KB

Idiom Library.pdf
me
Jun 12, 2011me
422 KB
APL
me
Jun 12, 2011me
—

Legacy_CheckFree_Associate_Appraisal_Form_2009.doc
me
May 25, 2011me
98 KB

Year End Review 2010 Mar 7 2011.pdf
me
Mar 7, 2011me
111 KB

One View Fiserv Press Release.pdf
me
Dec 7, 2010me
29 KB

APL Spider II 07.zip
me
Sep 24, 2010me
249 KB

APL Spider II 06.zip
me
Sep 23, 2010me
249 KB

APL Spider II 05.zip
me
Sep 22, 2010me
249 KB

APL Spider II 04.zip
me
Sep 21, 2010me
249 KB

APL Spider II 03.zip
me
Sep 20, 2010me
248 KB

APL Spider II 02.zip
me
Sep 20, 2010me
247 KB

APL Spider II.zip
me
Sep 20, 2010me
246 KB

APL Spider II.zip
me
Sep 18, 2010me
1 MB

APL Spider I.zip
me
Sep 13, 2010me
158 KB

Mid-Year Review 2010.pdf
me
Aug 17, 2010me
109 KB

SJHalasz Associate Annual Performance Appraisal 2008.doc
me
Jul 27, 2010me
194 KB

Legacy_CheckFree_Associate_Appraisal_Form_2009 - Halasz.doc
me
Jul 27, 2010me
99 KB

Legacy_CheckFree_Associate_Appraisal_Form_2009 - Halasz.doc
me
Jul 27, 2010me
—

APL Spider I.zip
me
May 25, 2010me
157 KB

APL Spider I.zip
me
May 25, 2010me
155 KB

APL Spider I.zip
me
May 23, 2010me
147 KB

APL Spider I.zip
me
May 22, 2010me
147 KB

APL Spider I.zip
me
May 20, 2010me
147 KB
My Drive
apl.js
All selections cleared 

﻿function apl() {

	quadio = 1;
	quadpp = 10;
	quadct = 1e-14;
	maxelements = 1000;
	
	function equals(a, b) {
		if(typeof a != typeof b) return false;
		if(typeof a == "number" && quadct !== 0)
			return (Math.abs(a - b) <= quadct * Math.max(Math.abs(a), Math.abs(b)));
		return a == b;
	}
	
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function (obj, fromIndex) {
			if (fromIndex === null)	fromIndex = 0;
			else if (fromIndex < 0) fromIndex = Math.max(0, this.length + fromIndex);
			for (var i = fromIndex, j = this.length; i < j; i++) { 
				if (this[i] === obj) return i; }
			return -1;
		};
	}
	
	this.array = array;
	
	function array(type, shape, data) {
		this.type = type; // "char" "numb" "arry" "mixd"
		this.shape = shape;
		this.data = data;
		validate(this); // validate for debugging; can be turned off for production run
	}
	
	this.empty = new array("numb", [0], []);
	this.emptymatrix = new array("numb", [0, 0], []);
	
	function validate(a) {
		var length = 1; var n;
		for(n = 0; n < a.shape.length; n++) length *= a.shape[n];
		if(length > maxelements) throw "LIMIT ERROR";
		if(length != a.data.length) {
			1;
			throw "array validation:  length error";
			}
		for(n = 0; n < length; n++) {
			var t = typeof(a.data[n]);
			switch(a.type) {
				case "char":
					if(t != "string") 
						throw "type error:  character";
					break;
				case "numb":
					if(t != "number") 
						throw "type error:  number";
					break;
				case "arry": // anything allowed
					break;
				case "mixd":
					if(t != "string" && t != "number") 
						throw "type error:  mixed";
					break;
				default: 
					throw "array validation:  type error:  " + a.type;
			}
		}
		return a;
	}
	
	function ptype(a) {
		switch(a.type)
		{
			case "char":return " "; break;
			case "numb":return 0; break;
			default: return " ";
		}return null;
	}
		
	function clone(a) {
		if(typeof a == "function") return a;
		// a.data is the only thing that can get changed in place--
		//    during selective assignment
		var newdata = [];
		for(var n = 0; n < a.data.length; n++)
			newdata[n] = a.data[n];
		return new array(a.type, a.shape, newdata);
	}
		
	this.shapeof = function(a) { 
		return new array("numb", [a.shape.length], a.shape); 
	};
		
	this.reshape = function(a, newshape) { 
		if(newshape.type != "numb") throw "DOMAIN ERROR";
		var length = 1;
		for(var n = 0; n < newshape.data.length; n++) length *= newshape.data[n];
		var d = a.data.slice(0,Math.min(length, a.data.length));
		var p = ptype(a);
		for(n = 0; n < Math.max(0, length - a.data.length); n++) 
			d[d.length] = (n < d.length) ? d[n] : p;
		return new array(a.type, newshape.data, d);	
	};

	this.thorn = thorn;
	function thorn(a) {
		switch(a.type) {
			case "char":return a; break;
			case "numb":return thorn_numb(a); break;
			case "arry":return thorn_arry(a); break;
			case "mixd":return thorn_mixd(a); break; default:break;
		}return null;
	};

	function padleft(array, length) {
		while(array.length < length) array = [" "].concat(array);
		return array;
	}

	function padright(array, length) {
		while(array.length < length) array = array.concat([" "]);
		return array;
	}

	function format_number(a) {
		// 0.01000 -> 0.01
		// 0.00    -> 0
		// 1000    -> 1000
		if(Math.abs(a) < quadct) a = 0;
		var s = a.toPrecision(quadpp).replace("-", "¯");
		var d = s.indexOf(".");
		if(d == -1) return s; // no decimal, do nothing
		var t = s.slice(0, d); // up to not including decimal
		s = s.slice(d);  // decimal to end
		while(s[s.length - 1] === "0") s = s.slice(0,s.length - 1);
		if(s.length == 1) return t;
		else return t + s;
	}
	
	function thorn_numb(a) {
		var rank = a.shape.length;
		if(rank === 0) { // scalar
			var t = format_number(a.data[0]);
			return new array("char", [t.length],  t.split(""));
		}
		var last = rank - 1; // last dimension
		var numcolumns = a.shape[last];
		var format = [];
		for(var n = 0; n < numcolumns; n++) format[n] = [-1, 0];
		var column = 0;
		var tempdata = [];
		for(n = 0; n < a.data.length; n++) {
			t = format_number(a.data[n]);
			var f = format[column];
			var i = t.indexOf(".");
			f[0] = Math.max(f[0], (i == -1) ? t.length : i); //left of decimal
			f[1] = Math.max(f[1], (i == -1) ? 0 : t.length - i); // decimal + right of decimal
			tempdata[n] = [i, t];
			column++;
			if(column == numcolumns) column = 0;
		}
		var totalwidth = 0;
		for(n = 0; n < numcolumns; n++) {
			var f = format[n];
			var d = f[0];
			var w = f[1];
			if(d == -1) d = 0;
			totalwidth += d + w ;
		}
		totalwidth = totalwidth + Math.max(0, numcolumns - 1);  // spaces between numbers
		var totalheight = 0;
		column = 0;
		var space = false;
		var newdata = [];
		for(n = 0; n < a.data.length; n++) {
			if(space) newdata = newdata.concat([" "]);
			t = tempdata[n];
			i = t[0]; t = t[1].split("");
			f = format[column];
			var d = f[0];
			var w = f[1];
			if(d != -1) { // decimal in this column
				var left;
				var right;
				if(i == -1) {left = t; right = []; } // no decimal 
				else {left = t.slice(0, i); right = t.slice(i); } // decimal
				t = padleft(left, d).concat(right);
				t = padright(t, w + d);
			}			
			else t = padleft(t, w);
			newdata = newdata.concat(t);
			space = true;
			column++;
			if(column == numcolumns) { column = 0; totalheight++; space = false; }
		}
		return new array("char", [totalheight, totalwidth], newdata);
	}

	function thorn_arry(a) {
		var rank = a.shape.length;
		if(rank === 0) { // scalar
			return thorn(a.data[0]);
		}
		var last = rank - 1; // last dimension
		var numcolumns = a.shape[last];
		var rlength = [];
		var clength = [];
		var column = 0;
		var row = 0;
		var tempdata = [];
		for(n = 0; n < a.data.length; n++) {
			t = thorn(a.data[n]);
			var c = clength[column];
			if(c == undefined) c = 0;
			var r = rlength[row];
			if(r == undefined) r = 0;
			c = Math.max(c, t.shape.length == 0 ? 1 : t.shape.last()); 
			var rlen = 1;
			for(var p = 0; p < t.shape.length - 1; p++) rlen *= t.shape[p];
			t.shape = [rlen, t.shape.last()]; // force matrix
			r = Math.max(r, rlen);
			clength[column] = c;
			rlength[row] = r;
			tempdata[n] = t;
			column++;
			if(column == numcolumns) {row++; column = 0};
		}
		var newdata = new array("char", [0, 0], []);
		var newrow = new array("char", [0, 0], []);
		column = 0;
		row = 0;
		for(n = 0; n < a.data.length; n++) {
			t = tempdata[n];
			var c = clength[column];
			if(column != numcolumns) c += 2; // ad space between columns
			t = take(t,new array("numb", [2], [rlength[row], c]));
			if(newrow.shape[0] < t.shape[0]) newrow = take(newrow, new array("numb", [2], [t.shape[0], newrow.shape[1]]));
			else if(t.shape[0] < newrow.shape[0]) t = take(t, new array("numb", [2], [newrow.shape[0], t.shape[1]]));
			newrow = catenate(t, newrow);
			column++;
			if(column == numcolumns) {
				if(newdata.shape[1] < newrow.shape[1]) newdata = take(newdata, new array("numb", [2], [newdata.shape[0], newrow.shape[1]]));
				else if(newrow.shape[1] < newdata.shape[1]) newrow = take(newrow, new array("numb", [2], [newrow.shape[0], newdata.shape[1]]));
				newdata = catenate(newrow, newdata, 0);
				column = 0;
				row++;
				newrow = new array("char", [0, 0], []);
			}
		}
		return newdata;
	}


	function thorn_mixd(a) {
		throw "thorn mixed:  nonce";
	}
	
	this.mscalar = mscalar;
	function mscalar(f, a) {
		var newdata = [];
		var isarry = a.type == "arry";
		for(var n = 0; n <a.data.length; n++) {
			var data = a.data[n];
			data = isarry ? mscalar(f, data) : f(a.data[n]);
			newdata[n] = data;
		}
		var t = isarry ? "arry" : "numb";
		return new array(t, a.shape, newdata);
	};
	this.conjugate = function(a) { return a; };
	this.negate = function(a) { return -a; };
	this.signum = function(a) { return (a < 0) ? -1 : (a === 0) ? 0 : 1; };
	this.reciprocal = function(a) { return 1 / a; };
	this.absolute = function(a) { return Math.abs(a); };
	this.ceiling = function(a) { return Math.ceil(a); }; // fuzz??
	this.floor = function(a) { return Math.floor(a); }; // fuzz??
	this.log = function(a) { return Math.log(a); };
	this.exponent = function(a) { return Math.exp(a); };
	this.pitimes = function(a) { return Math.PI * a; };
	this.roll = function(a) { return quadio + Math.floor(Math.random() * a); };
	this.not = function(a) {
		if(a == 1) return 0;
		if(a === 0) return 1;
		throw "DOMAIN ERROR";
	};
	
	this.factorial = function(a) { 
		switch(a) {
			case    1:   return   1.000000000E0   ;
			case    2:   return   2.000000000E0   ;
 			case    3:   return   6.000000000E0   ;
			case    4:   return   2.400000000E1   ;
			case    5:   return   1.200000000E2   ;
			case    6:   return   7.200000000E2   ;
			case    7:   return   5.040000000E3   ;
			case    8:   return   4.032000000E4   ;
			case    9:   return   3.628800000E5   ;
			case   10:   return   3.628800000E6   ;
			case   11:   return   3.991680000E7   ;
			case   12:   return   4.790016000E8   ;
			case   13:   return   6.227020800E9   ;
			case   14:   return   8.717829120E10  ;
			case   15:   return   1.307674368E12  ;
			case   16:   return   2.092278989E13  ;
			case   17:   return   3.556874281E14  ;
			case   18:   return   6.402373706E15  ;
			case   19:   return   1.216451004E17  ;
			case   20:   return   2.432902008E18  ;
			case   21:   return   5.109094217E19  ;
			case   22:   return   1.124000728E21  ;
			case   23:   return   2.585201674E22  ;
			case   24:   return   6.204484017E23  ;
			case   25:   return   1.551121004E25  ;
			case   26:   return   4.032914611E26  ;
			case   27:   return   1.088886945E28  ;
			case   28:   return   3.048883446E29  ;
			case   29:   return   8.841761994E30  ;
			case   30:   return   2.652528598E32  ;
			case   31:   return   8.222838654E33  ;
			case   32:   return   2.631308369E35  ;
			case   33:   return   8.683317619E36  ;
			case   34:   return   2.952327990E38  ;
			case   35:   return   1.033314797E40  ;
			case   36:   return   3.719933268E41  ;
			case   37:   return   1.376375309E43  ;
			case   38:   return   5.230226175E44  ;
			case   39:   return   2.039788208E46  ;
			case   40:   return   8.159152832E47  ;
			case   41:   return   3.345252661E49  ;
			case   42:   return   1.405006118E51  ;
			case   43:   return   6.041526306E52  ;
			case   44:   return   2.658271575E54  ;
			case   45:   return   1.196222209E56  ;
			case   46:   return   5.502622160E57  ;
			case   47:   return   2.586232415E59  ;
			case   48:   return   1.241391559E61  ;
			case   49:   return   6.082818640E62  ;
			case   50:   return   3.041409320E64  ;
			case   51:   return   1.551118753E66  ;
			case   52:   return   8.065817517E67  ;
			case   53:   return   4.274883284E69  ;
			case   54:   return   2.308436973E71  ;
			case   55:   return   1.269640335E73  ;
			case   56:   return   7.109985878E74  ;
			case   57:   return   4.052691950E76  ;
			case   58:   return   2.350561331E78  ;
			case   59:   return   1.386831185E80  ;
			case   60:   return   8.320987113E81  ;
			case   61:   return   5.075802139E83  ;
			case   62:   return   3.146997326E85  ;
			case   63:   return   1.982608315E87  ;
			case   64:   return   1.268869322E89  ;
			case   65:   return   8.247650592E90  ;
			case   66:   return   5.443449391E92  ;
			case   67:   return   3.647111092E94  ;
			case   68:   return   2.480035542E96  ;
			case   69:   return   1.711224524E98  ;
			case   70:   return   1.197857167E100 ;
			case   71:   return   8.504785886E101 ;
			case   72:   return   6.123445838E103 ;
			case   73:   return   4.470115462E105 ;
			case   74:   return   3.307885442E107 ;
			case   75:   return   2.480914081E109 ;
			case   76:   return   1.885494702E111 ;
			case   77:   return   1.451830920E113 ;
			case   78:   return   1.132428118E115 ;
			case   79:   return   8.946182131E116 ;
			case   80:   return   7.156945705E118 ;
			case   81:   return   5.797126021E120 ;
			case   82:   return   4.753643337E122 ;
			case   83:   return   3.945523970E124 ;
			case   84:   return   3.314240135E126 ;
			case   85:   return   2.817104114E128 ;
			case   86:   return   2.422709538E130 ;
			case   87:   return   2.107757298E132 ;
			case   88:   return   1.854826423E134 ;
			case   89:   return   1.650795516E136 ;
			case   90:   return   1.485715964E138 ;
			case   91:   return   1.352001528E140 ;
			case   92:   return   1.243841405E142 ;
			case   93:   return   1.156772507E144 ;
			case   94:   return   1.087366157E146 ;
			case   95:   return   1.032997849E148 ;
			case   96:   return   9.916779349E149 ;
			case   97:   return   9.619275968E151 ;
			case   98:   return   9.426890449E153 ;
			case   99:   return   9.332621544E155 ;
			case  100:   return   9.332621544E157 ;
			default: throw "NONCE ERROR";
		}
		return null; 
	};
	
	this.dscalar = dscalar;
	function dscalar(f, right, left) {
		var scalarleft = left.data.length == 1;
		var scalarright = right.data.length == 1;
		if(!scalarleft && !scalarright && left.data.length != right.data.length)
			throw "LENGTH ERROR";
		var rightisarry = right.type == "arry";
		var leftisarry = left.type == "arry";
		var bothisarry = rightisarry && leftisarry;
		var newdata = [];
		var newshape = scalarleft ? right.shape : left.shape;
		var count = Math.max(left.data.length, right.data.length);
		for(var n = 0; n < count; n++) {	
			var leftdata = left.data[scalarleft ? 0 : n];
			var rightdata = right.data[scalarright ? 0 : n]; 
			if(bothisarry) {
				data = dscalar(f, rightdata, leftdata);
			} else if(leftisarry) {
				data = dscalar(f, new array(right.type, [], [rightdata]), leftdata);
			} else if(rightisarry) {
				data = dscalar(f, rightdata, new array(left.type, [], [leftdata]));
			} else {
				data = f(leftdata, rightdata);
			}
			newdata[n] = data;
		}
		var t = (rightisarry || leftisarry) ? "arry" : "numb";
		return new array(t, newshape, newdata);
	};
	
	this.add = function(a, b) { return a + b; };
	this.subtract = function(a, b) { return a - b; };
	this.multiply = function (a, b) { return a * b; };
	this.divide = function(a, b) { return a / b; };
	this.power = function(a, b) { return Math.pow(a, b); };
	this.residue = function(a, b) { // fuzz??
		if(a !== 0) return (a < 0 || b < 0) ? b - (a * Math.floor(b / a)) : b % a; 
		else return b; 
	};
	this.maximum = function(a, b) { return Math.max(a, b); };
	this.minimum = function(a, b) { return Math.min(a, b); };
	function posint(a) { return a === Math.floor(a) && a > 0; }
	function integer(a) { return a === Math.floor(a); }
	function nnegint(a) { return integer(a) && a >= 0; }
	function bool(a) { return a === 0 || a === 1; }
	this.deal = function(b, a) { 
		if(a.data.length != 1 || b.data.length != 1) throw "LENGTH ERROR";
		if(a.type != "numb" || b.type != "numb") throw "DOMAIN ERROR";
		if(!posint(a.data[0]) || !posint(b.data[0])) throw "DOMAIN ERROR";
		if(a.data[0] > b.data[0]) throw "DOMAIN ERROR";
		if(b.data[0] <= 10000) {
			var d = [];
			for(var n = 0; n < b.data[0]; n++) d[d.length] = n;
			for(n = 0; n < a.data[0]; n++){
				var i = this.roll(d.length - 1) - quadio;
				r[r.length] = d[i];
				d.splice(i, 1);
			}
		} else {
			var r = [];
			for(n = 0; n < a.data[0]; n++) {
				var p;
				while(true) {
					p = this.roll(b.data[0]);
					if(-1 == r.indexOf(p)) break;
				}
				r[r.length] = p;
			}
		}
		return new array("numb", [r.length], r); 
	};

	function gcd(x, y) {
		while (y !== 0) {
			var z = x % y;
			x = y;
			y = z;
		}
		return x;
	}
	this.or = function(b, a) {
		if(a === 0) { if(b === 0) return 0; else if(b == 1) return 1; }
		if(a == 1) return 1;
		return gcd(Math.abs(a), Math.abs(b));
	};
	function lcm(a, b) { 
		return ( a / gcd(a,b) ) * b; 
	}	
	this.and = function(b, a) {
		if(a == 1) { if(b === 0) return 0; else if(b == 1) return 1; }
		if(a === 0) return 0;
		return lcm(Math.abs(a), Math.abs(b));
	}; 
	this.nand = function(a, b) {return (a == 1 && b == 1) ? 0 : 1;};
	this.nor = function(a, b) { return (a == 1 || b == 1) ? 0 : 1; };
	this.less = function(a, b) { 
       return equals(a, b) ? 0 : ((a < b) ? 1 : 0); 
       };
	this.lessequal = function(a, b) { 
       return equals(a, b) ? 1 : ((a < b) ? 1 : 0); 
       };
	this.equal = function(a, b) { return equals(a, b) ? 1 : 0; };
	this.greaterequal = function(a, b) { 
       return equals(a, b) ? 1 : ((a > b) ? 1 : 0); 
       };
	this.greater = function(a, b) { 
       return equals(a, b) ? 0 : ((a > b) ? 1 : 0); 
       };
	this.notequal = function(a, b) { return equals(a, b) ? 0 : 1; };
	this.circle = function(b, a) {
		switch(a) {
			case 0:return Math.sqrt(1-Math.pow(a, 2)); 
			case -1:return Math.asin(a); 
			case 1:return Math.sin(a); 
			case -2:return Math.acos(a); 
			case 2:return Math.cos(a); 
			case -3:return Math.atan(a); 
			case 3:return Math.tan(a); 
			case -4:return (a + 1) * Math.sqrt((a - 1) / (a + 1)); 
			case 4:return Math.sqrt(1 + Math.pow(a, 2)); 
			case -5:return Math.log(a + Math.sqrt(a * a + 1)); 
			case 5:return (Math.exp(a) - Math.exp(-a)) / 2; 
			case -6:return Math.log(a + Math.sqrt(a * a - 1)); 
			case 6:return (Math.exp(a) + Math.exp(-a)) / 2; 
			case -7:return 0.5 * Math.log((1 + a) / (1 - a)); 
			case 7:return (Math.exp(a) - Math.exp(-a)) / (Math.exp(a) + Math.exp(-a)); 
			case -8:return -Math.sqrt(-(1 + Math.pow(a, 2))); 
			case 8:return Math.sqrt(-(1 + Math.pow(a, 2))); 
			default: throw "DOMAIN ERROR";
		}
	};
	
	this.binomial = function(b, a) {
		if(a == Math.floor(a) && b == Math.floor(b))
			return factorial(a) / (factorial(b) * factorial(b - a));
		else throw "NONCE ERROR";
	};

	function decode(base, array) {
		var r = 0;
		var f = 1;
		for(var n = base.length - 1; n >= 0; n--) {
			r += f * array[n];
			f *= base[n];
		}
		return r;
	}

	function decodesub(base, array, element, value) { // decode with substitution
		var r = 0;
		var f = 1;
		for(var n = base.length - 1; n >= 0; n--) {
			r += f * ((n == element) ? value : array[n]);
			f *= base[n];
		}
		return r;
	}
	
	function rdecode(base, array) {
		var r = 0;
		var f = 1;
		for(var n = 0; n < base.length ; n++) {
			r += f * array[n];
			f *= base[n];
		}
		return r;
	}

	this.reduce = function(x, f, a, xx) { 
		if(typeof xx == "object") xx = xx[0].data[0] - quadio;
		if(a.shape.length === 0) return a.data; // scalars returned unaltered
		if(x == -1) x = a.shape.length - 1;
		var newshape = [];
		var newlength = 1;
		for(var n = 0; n < a.shape.length; n++) {
			if(n != x) {
				var len = a.shape[n];
				newshape[(n < x) ? n : n - 1] = len; 
				newlength *= len;
			}
		}
		var newdata = [];
		if(a.shape[x] === 0) {
			var ident = this.identity(f);
			if(ident == undefined) throw "DOMAIN ERROR";
			for(var n = 0; n < newlength; n++)	
				newdata[n] = ident;
			return new array("numb", newshape, newdata);
		}
		var oldcounter = [];
		for(n = 0; n < a.shape.length; n++) oldcounter[n] = a.shape[n] - 1;
		var newcounter = [];
		for(n = 0; n < newshape.length; n++) newcounter[n] = newshape[n] - 1;
		var oldlast = a.shape.length - 1;
		var newlast = newshape.length - 1;
		for(n = a.data.length - 1; n >=0 ; n--) {
			var i = decode(newshape, oldcounter.slice(0,x).concat(newcounter.slice(x)));
			if(oldcounter[x] == a.shape[x] - 1) newdata[i] = a.data[n];
			else newdata[i] = f(a.data[n], newdata[i]);
			oldcounter[oldlast]--;
			var olddimension = oldlast;
			while(oldcounter[olddimension] < 0) {
				oldcounter[olddimension] = a.shape[olddimension] - 1;
				oldcounter[--olddimension]--;
			}
			newcounter[newlast]--;
			var newdimension = newlast;
			while(newcounter[newdimension] < 0) {
				newcounter[newdimension] = newshape[newdimension] - 1;
				newdimension--; if(newdimension < x) break;
				newcounter[newdimension]--;
			}
		}
		// for now, all reductions return numeric
		return new array("numb", newshape, newdata);
	};
	
	this.scan = function(x, f, a, xx) {
		if(typeof xx == "object") xx = xx[0].data[0] - quadio;
		if(xx != undefined) x = xx;
		if(a.shape.length === 0) return a;
		if(x == -1) x = a.shape.length - 1;
		var newdata = a.data.slice(0);
		var counter = [];
		for(var n = 0; n < a.shape.length; n++) counter[n] = 0;
		var last = a.shape.length - 1;
		mainloop:while(true) {
			counter[x] = 0;
			var oldn = decode(a.shape, counter);
			for(n = 1; n < a.shape[x]; n++) {
				counter[x]++;
				var newn = decode(a.shape, counter);
				newdata[newn] = f(newdata[oldn], newdata[newn]);
				oldn = newn;
			}
			if(last < 0) break;
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == a.shape[dimension]) {
				counter[dimension] = 0;dimension--;
				if(dimension < 0) break mainloop;
				counter[dimension]++;
			}
		}
		// all scans are numeric for now
		return new array("numb", a.shape, newdata);
	};
	
	this.ravel = function(a) {
		return new array(a.type, [a.data.length], a.data);
	};
	
	this.reverse1 = function(a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(x == undefined) x = 0;
		return this.reverse(x, a);
	}

	this.reverse = function(x, a, xx) {
		if(typeof xx == "object") x = xx[0].data[0] - quadio;
		if(a.data.length == 1) return a;
		if(x == -1) x = a.shape.length - 1;
		var newdata = a.data.slice(0);
		var counter = [];
		for(var n = 0; n < a.shape.length; n++) counter[n] = 0;
		var last = a.shape.length - 1;
		var lastindex = a.shape[x] - 1;
		mainloop:while(true) {
			for(n = 0; n < Math.floor(a.shape[x] / 2); n++) {
				counter[x] = n;
				var na = decode(a.shape, counter);
				counter[x] = lastindex - n;
				var nb = decode(a.shape, counter);
				var t = newdata[na];
				newdata[na] = newdata[nb];
				newdata[nb] = t;
			}
			if(last < 0) break;
			counter[x] = lastindex;
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == a.shape[dimension]) {
				counter[dimension] = 0;dimension--;
				if(dimension < 0) break mainloop;
				counter[dimension]++;
			}
		}
		return new array(a.type, a.shape, newdata);
	};
	
	this.transpose = function(a) {
		if(a.shape.length === 0) return a;
		var newdata = a.data.slice(0);
		var counter = [];
		var newshape = a.shape.slice(0);
		newshape.reverse();
		var last = a.shape.length - 1;
		for(var n = 0; n < a.shape.length; n++) counter[n] = 0;
		for(n = 0; n < a.data.length; n++) {
			var i = rdecode(a.shape, counter);
			newdata[i] = a.data[n];
			counter[last]++;
			var dimension = last;
			while(counter[dimension] == a.shape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(a.type, newshape, newdata);
	};

	this.catenate1 = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		else x = 0;
		return this.catenate(b, a, x);
	};
	
	this.catenate = catenate;
	function catenate(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(a.type == "arry" || b.type == "arry") t = "arry";
		else if(a.type != b.type) t = "mixd";
		else t = a.type;
		// special case both rank 1 or less
		if(a.shape.length < 2 && b.shape.length < 2)	
			return new array(t, [a.data.length + b.data.length], a.data.concat(b.data));
		// treat scalars as one element vectors
		var shapea = a.shape.slice(0);
		if(shapea.length === 0) shapea = [1];
		var shapeb = b.shape.slice(0);
		if(shapeb.length === 0) shapeb = [1];
		var rank = Math.max(shapea.length, shapeb.length);
		if(x == undefined || x == -1) x = rank - 1; // last axis
		// singleton extension
		if(a.data.length == 1) {
			for(var n = 0; n < rank; n++) shapea[n] = shapeb[n];
			shapea[x] = 1;
		}
		if(b.data.length == 1) {
			for(n = 0; n < rank; n++) shapeb[n] = shapea[n];
			shapeb[x] = 1;
		}
		// extend the lesser rank to be 1 at axis
		if(shapea.length < rank) shapea.splice(x, 0, 1);
		if(shapeb.length < rank) shapeb.splice(x, 0, 1);
		if(shapea.length != rank || shapeb.length != rank) throw "RANK ERROR";
		for(n = 0; n < rank; n++) {
			if(n != x && shapea[n] != shapeb[n]) throw "LENGTH ERROR"; }
		var newshape = shapea.slice(0); // shape of result
		newshape[x] = shapea[x] + shapeb[x];
		var length = 1;
		for(n = 0; n < rank; n++) length *= newshape[n];
		var counter = [];
		for(n = 0; n < rank; n++) counter[n] = 0;
		var last = rank - 1;
		var newdata = [];
		for(n = 0; n < length; n++) {
			var t, i;
			if(counter[x] < shapea[x]) { // take from a
				i = decode(shapea, counter);
				t = a.data[(i < a.data.length) ? i : 0];
			} else { // take from b
				i = decodesub(shapeb, counter, x, counter[x] - shapea[x]);
				t = b.data[(i < b.data.length) ? i : 0];
			}
			newdata[n] = t;
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(a.type, newshape, newdata);
	};
	
	this.rotate1 = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(x == undefined) x = 0;
		return this.rotate(b, a, x);
	};
	
	this.rotate = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(b.data.length == 1) return b;
		// shape of a must be shape of b with x missing
		var scalara = a.data.length == 1;
		if(scalara && a.data[0] === 0) return b; // special case scalar zero rotation
		if(x == undefined || x == -1) x = b.shape.length - 1;
		if(!scalara) {
			if(a.shape.length != b.shape.length - 1) throw "RANK ERROR";
			for(var n = 0; n < b.shape.length; n++) {
				if(n != x && a.shape[(n > x) ? n - 1 : n] != b.shape[n])
					throw "LENGTH ERROR"; }
		}
		var newdata = b.data.slice(0);
		var counter = [];
		for(n = 0; n < b.shape.length; n++) counter[n] = 0;
		var last = b.shape.length - 1;
		if(scalara) rotation = a.data[0];
		var lastindex = b.shape[x] - 1;
		for(n = 0; n < b.data.length; n++) {
			if(!scalara) {
				var countera = counter.slice(0); // clone the counter
				countera.splice(x, 1);  // remove the rotated axis
				rotation = a.data[decode(a.shape, countera)];
			}
			if(rotation !== 0) {
				var counterb = counter.slice(0);
				for(var p = 0; p < b.shape[x]; p++) {
					//counter[x] = (p + rotation) % b.shape[x];
					counter[x] = this.residue(b.shape[x], p + rotation);
					counterb[x] = p;
					newdata[decode(b.shape, counterb)] = b.data[decode(b.shape, counter)];
				}
			}
			counter[x] = lastindex;  // makes counter update work right
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == b.shape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(b.type, b.shape, newdata);
	};
	
	this.unique = function(a) { // fuzz?
		if(a.shape.length > 1) throw "RANK ERROR";
		var newdata = [];
		for(var n = 0; n < a.data.length; n++) {
			if(-1 == newdata.indexOf(a.data[n]))
				newdata.push(a.data[n]);}
		return new array(a.type, [newdata.length], newdata);
	};
	
	this.take = take;
	function take(b, a) {
		if(a.type != "numb") throw "DOMAIN ERROR";
		if(a.shape.length > 1) throw "RANK ERROR";
		if(a.data.length != b.shape.length) throw "LENGTH ERROR";
		var newshape = a.data.slice(0);
		var negative = [];
		var counter = [];
		var offset = [];
		var length = 1;
		for(var n = 0; n < newshape.length; n++) {
			negative[n] = newshape[n] < 0;
			newshape[n] = Math.abs(newshape[n]);
			counter[n] = 0;
			offset[n] = b.shape[n] - newshape[n];
			length *= newshape[n];
		}
		var p = ptype(b);
		var newdata = []; 
		var last = counter.length - 1;
		for(n = 0; n < length; n++) {
			var counterb = counter.slice(0); // clone the counter
			var copy = true;
			for(var x = 0; x < counterb.length; x++) {
				if(negative[x]) counterb[x] += offset[x];
				if(counterb[x] < 0 || counterb[x] >= b.shape[x]) { // if not copying this element
					copy = false;
					break; 
				}
			}
			newdata[n] = copy ? b.data[decode(b.shape, counterb)] : p;
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(b.type, newshape, newdata);
	};
	
	this.drop = function(b, a) {
		if(a.type != "numb") throw "DOMAIN ERROR";
		if(a.shape.length > 1) throw "RANK ERROR";
		if(a.data.length != b.shape.length) throw "LENGTH ERROR";
		var newshape = a.data.slice(0);
		var negative = [];
		var counter = [];
		var offset = [];
		var length = 1;
		for(var n = 0; n < newshape.length; n++) {
			// convert drop to take and do the same as take
			negative[n] = newshape[n] > 0;
			newshape[n] = Math.max(0, b.shape[n] - Math.abs(newshape[n]));
			counter[n] = 0;
			offset[n] = b.shape[n] - newshape[n];
			length *= newshape[n];
		}
		var p = ptype(b);
		var newdata = []; 
		var last = counter.length - 1;
		for(n = 0; n < length; n++) {
			var counterb = counter.slice(0); // clone the counter
			var copy = true;
			for(var x = 0; x < counterb.length; x++) {
				if(negative[x]) counterb[x] += offset[x];
				if(counterb[x] < 0 || counterb[x] >= b.shape[x]) { // if not copying this element
					copy = false;
					break; 
				}
			}
			newdata[n] = copy ? b.data[decode(b.shape, counterb)] : p;
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(b.type, newshape, newdata);
	};
	
	this.replicate1 = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		else x = 0;
		return this.replicate(b, a, x);
	};
	
	this.replicate = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(a.type != "numb") throw "DOMAIN ERROR";
		if(a.shape.length > 1) throw "RANK ERROR";
		var scalara = a.data.length == 1;
		var scalarb = b.shape.length === 0;
		if(x == undefined || x == -1) x = scalarb ? 0 : b.shape.length - 1;
		if(!nnegint(x) || (!scalarb && x > b.shape.length - 1)) 
			throw "AXIS ERROR";
		if(!scalara && !scalarb && a.data.length != b.shape[x]) 
			throw "LENGTH ERROR";
		// for result element, what source element does it come from?
		var source = [];
		if(scalara) {
			if(!nnegint(a.data[0])) throw "DOMAIN ERROR";
			for(var n = 0; n < (scalarb ? 1 : b.shape[x]); n++) {
				for(var p = 0; p < a.data[0]; p++)
					source[source.length] = n;}
		} else {
			for(n = 0; n < a.data.length; n++) {
				if(!nnegint(a.data[n])) throw "NONCE ERROR";
				for(p = 0; p < a.data[n]; p++)	source[source.length] = n;
			}
		}	
		var newshape = b.shape.slice();
		newshape[x] = source.length;
		var length = 1;
		var counter = [];
		for(n = 0; n < newshape.length; n++) {
			length *= newshape[n];
			counter[n] = 0;
		}	
		var newdata = [];
		if(length === 0) return new array(b.type, newshape, newdata);
		var last = newshape.length - 1;
		for(n = 0; n < length; n++) {
			newdata[n] = scalarb ? b.data[0] : b.data[decodesub(b.shape, counter, x, source[counter[x]])];
				
				
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(b.type, newshape, newdata);
	};
	
	this.expand1 = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(x == undefined) x = 0;
		return this.expand(b, a, x);
	};
	
	this.expand = function(b, a, x) {
		if(typeof x == "object") x = x[0].data[0] - quadio;
		if(a.type != "numb") throw "DOMAIN ERROR";
		if(a.shape.length > 1) throw "RANK ERROR";
		var scalarb = b.shape.length === 0;
		if(x == undefined || x == -1) x = scalarb ? 0 : b.shape.length - 1;
		if(!nnegint(x) || (!scalarb && x > b.shape.length - 1)) 
			throw "AXIS ERROR";
		var count = 0;
		var source = []; // where data comes from for this element
		var index = 0;
		for(var n = 0; n < a.data.length; n++) {
			var e = a.data[n];
			if(!bool(e)) throw "NONCE ERROR";
			source[n] = e ? index++ : -1;
			count += e;
		}
		if(!scalarb && count != b.shape[x]) throw "LENGTH ERROR";
		var newshape = b.shape.slice();
		newshape[x] = source.length;
		var counter = [];
		var length = 1;
		for(n = 0; n < newshape.length; n++) {
			counter[n] = 0;
			length *= newshape[n];
		}	
		var newdata = [];
		var last = newshape.length - 1;
		var p = ptype(b);
		for(n = 0; n < length; n++) {
			var sourcex = source[counter[x]];
			if(-1 == sourcex) newdata[n] = p;
			else {
				newdata[n] = scalarb ? b.data[0] : b.data[decodesub(b.shape, counter, x, sourcex)];
					
					
			}	
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(b.type, newshape, newdata);
	};
	
	this.excluding = function(b, a) {
		if(a.shape.length > 1) throw "RANK ERROR";
		var newdata = a.data.slice(0); // clone
		for(var n = 0; n < newdata.length; n++){
			for(var p = 0; p < b.data.length; p++) {
				if(equals(newdata[n], b.data[p])) {
					newdata.splice(n, 1);
					break;
				}}}	
		return new array(a.type, [newdata.length], newdata);
	};
	
	this.intersection = function(b, a) {
		throw "NONCE ERROR";
	};
	
	this.union = function(b, a) {
		throw "NONCE ERROR";
	};
	
	this.indexgen = function(a) {
		if(a.data.length != 1) throw "NONCE ERROR";
		if(!nnegint(a.data[0])) throw "DOMAIN ERROR";
		var newdata = [];
		for(var n = 0; n < a.data[0]; n++)
			newdata[n] = n + quadio;
		return new array("numb", [newdata.length], newdata);
	};
	
	this.gradeup = function(a) {
	 	a = this.table(a); // always treat a as matrix  
		var offset = [];
		var newdata = [];
		var width = a.shape[1];
		for(var n = 0; n < a.shape[0]; n++) { 
			offset[n] = n * width;
			newdata.push(n);
		}
		function sortfn(left, right) {
			for(var p = 0; p < width ; p++) {
				var aval = a.data[p + offset[left]];
				var bval = a.data[p + offset[right]];
				if(aval > bval) return 1;
				else if (aval < bval) return -1;	
			}
			return left - right;
		}
		newdata.sort(sortfn);
		if(quadio) {for(n = 0; n < newdata.length; n++) newdata[n]++;}
		return new array("numb", [newdata.length], newdata);
	};
	
	this.table = function(a) {
		var newshape = [1, 1];
		for(var n = 0; n < a.shape.length; n++){
			if(n === 0) newshape[0] = a.shape[0];
			else newshape[1] *= a.shape[n];}
		return new array(a.type, newshape, a.data);
	};
	
	this.gradedown = function(a) {
	 	a = this.table(a); // always treat a as matrix  
		var offset = [];
		var newdata = [];
		var width = a.shape[1];
		for(var n = 0; n < a.shape[0]; n++) { 
			offset[n] = n * width;
			newdata.push(n);
		}
		function sortfn(left, right) {
			for(var p = 0; p < width ; p++) {
				var aval = a.data[p + offset[left]];
				var bval = a.data[p + offset[right]];
				if(aval > bval) return -1;
				else if (aval < bval) return 1;	
			}
			return right - left;
		}
		newdata.sort(sortfn);
		if(quadio) {for(n = 0; n < newdata.length; n++) newdata[n]++;}
		return new array("numb", [newdata.length], newdata);
	};
	
	this.cindex = function(index, a) {
		return this.index([null, index], a);
	}
	this.rindex = function(index, a) {
		return this.index([index, null], a);
	}
	this.rcindex = function(cindex, rindex, a) {
		return this.index([rindex, cindex], a);
	}
	this.vindex = function(index, a) {
		return this.index([index], a);
	}
	this.index = function(index, a) { // index is a javascript array of apl arrays or nulls
		//if(a.shape.length != index.length) throw "RANK ERROR";
		var newshape = [];
		var newlength = [];
		for(var n = 0; n < index.length; n++) { 
			if(!index[n]) index[n] = this.indexgen(new array("numb", [], [a.shape[n]]));
			newshape = newshape.concat(index[n].shape);
			newlength[n] = index[n].data.length;
		}
		var length = 1;
		for(n = 0; n < newshape.length; n++) length *= newshape[n];
		var last = newlength.length - 1;
		var newdata = [];
		var counter = [];
		for(n = 0; n < newlength.length; n++) counter[n] = 0;
		for(n = 0; n < length; n++) {
			var f = 1;
			var i = 0;
			for(var p = index.length - 1; p >= 0; p--) {
				var x = index[p].data[counter[p]];
				// validation here is redundant for repeat indices but that's unusual
				if(!posint(x) || x > a.shape[p]) throw "INDEX ERROR"; 
				i += f * (x - quadio);
				f *= a.shape[p];
			}	
			newdata[n] = a.data[i]; 
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newlength[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array(a.type, newshape, newdata);
	};

	this.vindexassign = function(source, index, target) {
		return this.indexassign(source, [index], target);
	}
	this.rindexassign = function(source, index, target) {
		return this.indexassign(source, [index, null], target);
	}
	this.cindexassign = function(source, index, target) {
		return this.indexassign(source, [null, index], target);
	}
	this.rcindexassign = function(source, cindex, rindex, target) {
		return this.indexassign(source, [rindex, cindex], target);
	}
	this.indexassign = function(source, index, target) { // index is a javascript array of apl arrays or null
		if(target.shape.length != index.length) throw "RANK ERROR";
		// change target in place and return it
		// rank is the larger of rank of index or source
		var indexshape = [];
		var indexlength = [];
		var datalength = 1;
		for(var n = 0; n < index.length; n++) { 
			if(!index[n]) index[n] = this.indexgen(new array("numb", [], [target.shape[n]]));
			if(index[n].data.length != 1) // scalar/singleton 
				indexshape = indexshape.concat(index[n].shape);
			var len = index[n].data.length;
			indexlength[n] = len;
			datalength *= len;
		}
		var singleton = source.data.length == 1;
		if(!singleton) {
			var sourceshape = [];
			for(var n = 0; n < source.shape.length; n++) {
				if(source.shape[n] != 1)
					sourceshape.push(source.shape[n]);
			}
			if(indexshape.length != sourceshape.length) throw "RANK ERROR";
			for(var n = 0; n < indexshape.length; n++) {
				if(indexshape[n] != sourceshape[n]) throw "LENGTH ERROR";
			}
		}
		var counter = []; // counter in index
		for(var n = 0; n < indexlength.length; n++) counter[n] = 0;
		var last = counter.length - 1;
		var idx = [];
		for(n = 0; n < datalength; n++) {
			for(var p = 0; p < indexlength.length; p++)
				idx[p] = index[p].data[counter[p]] - quadio;  // redundancy here
			target.data[decode(target.shape, idx)] = source.data[singleton ? 0 : n];  
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == indexlength[dimension]) {
				counter[dimension] = 0;
				dimension--;
				counter[dimension]++;
			}
		}
		return source;
	};

	this.indexof = function(b, a) { // fuzz??
		if(a.shape.length != 1) throw "LENGTH ERROR";
		var newdata = [];
		for(var n = 0; n < b.data.length; n++) {
			var i = a.data.indexOf(b.data[n]);
			newdata[n] = (i == -1) ? a.data.length : i;
			if(quadio) newdata[n]++;
		}
		return new array("numb", b.shape, newdata);
	};
	
	this.memberof = function(b, a) { // fuzz??
		var newdata = [];
		for(var n = 0; n < a.data.length; n++) 
			newdata[n] = (-1 == b.data.indexOf(a.data[n])) ? 0 : 1;
		return new array("numb", a.shape, newdata);
	};
	
	this.decode = function(b, a) {
		var scalara = a.data.length == 1 || a.shape[a.shape.length - 1] == 1;
		var scalarb = b.data.length == 1 || b.shape[0] == 1;
		var usea = Math.max(0, a.shape.length - 1);
		var useb = Math.max(0, b.shape.length - 1);
		if(!scalara && !scalarb && (a.shape[usea] != b.shape[0])) throw "LENGTH ERROR";
		var rank = usea + useb;
		var newshape = [];
		var length = 1;
		for(var n = 0; n < rank; n++) {
			if(n < usea) newshape[n] = a.shape[n];
			else newshape[n] = b.shape[1 + n - usea];
			length *= newshape[n];
		}
		var last = newshape.length - 1;
		var newdata = [];
		var counter = [];
		var radixlength;
		if(scalara) 
			radixlength = scalarb ? 1 : b.shape[0];
		else 
			radixlength = a.shape[a.shape.length - 1];
		for(n = 0; n < newshape.length; n++) counter[n] = 0;
		for(n = 0; n < length; n++) {
			newdata[n] = 0;
			var f = 1;
			for(var p = radixlength - 1; p >= 0; p--) {
				var na = decode(a.shape, counter.slice(0, usea).concat(scalara ? 0 : p));
				var nb = decode(b.shape, [scalarb ? 0 : p].concat(counter.slice(usea, newshape.length)));
				newdata[n] += f * b.data[nb];
				f *= a.data[na];
			}
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array("numb", newshape, newdata);
	};
	
	this.encode = function(b, a) {
		var scalara = a.data.length == 1;
		var scalarb = b.data.length == 1;
		var newshape = [];
		var newshape1 = [];
		var length = 1;
		var rank = a.shape.length + b.shape.length;
		for(var n = 0; n < a.data.length; n++)
			if(!integer(a.data[n])) throw "NONCE ERROR"; // yeesh!
		for(var n = 0; n < rank; n++) {
			if(n < a.shape.length) newshape[n] = a.shape[n];
			else newshape[n] = b.shape[n - a.shape.length];
			if(n > 0) {
				newshape1[n - 1] = newshape[n];
				length *= newshape[n];
			}
		}
		var last = newshape1.length - 1;
		var newdata = [];
		var counter = [];
		var radixlength = scalara ? 1 : a.shape[0];
		for(n = 0; n < newshape1.length; n++) counter[n] = 0;
		for(n = 0; n < length; n++) {
			var bi = b.data[decode(b.shape, counter.slice(a.shape.length - 1))];
			for(var p = radixlength - 1; p >= 0; p--) {
				var ai = decode(a.shape, [p].concat(counter.slice(0, a.shape.length - 1)));
				var zi = decode(newshape, [p].concat(counter));
				newdata[zi] = this.residue(a.data[ai], bi);
				bi = (a.data[ai] === 0) ? 0 : Math.floor(bi / a.data[ai]);
			}
			var dimension = last;
			counter[last]++;
			while(counter[dimension] == newshape1[dimension]) {
				counter[dimension] = 0;dimension--;
				counter[dimension]++;
			}
		}
		return new array("numb", newshape, newdata);
	};
	
	this.toThorn = function(a) {
		if(a && typeof a != "function" && a.type != "char") a = this.thorn(a);
		return a;
		}	

	this.tokenize = function(s) {
		var token;
		var tokens = [];
		var state = "begin";
		for(var n = 0; n < s.length; n++) {
			var c = s.substr(n, 1);
			switch(c) {
			case " ":
				switch(state) {
					case "begin":
						break;
					case "comment":
					case "quote1":
						token += c;
						break;
					case "strand":
					case "number":
						token += ",";
						while(s[n + 1] == " ") n++; // move past redundant blanks
						state = "strand";
						break;
					default:
						tokens.push([state, token]);
						state = "begin";break;
				}
				break;
			case "_":
			case "a":
			case "b":
			case "c":
			case "d":
			case "e":
			case "f":
			case "g":
			case "h":
			case "i":
			case "j":
			case "k":
			case "l":
			case "m":
			case "n":
			case "o":
			case "p":
			case "q":
			case "r":
			case "s":
			case "t":
			case "u":
			case "v":
			case "w":
			case "x":
			case "y":
			case "z":
			case "∆":
			case "A":
			case "B":
			case "C":
			case "D":
			case "E":
			case "F":
			case "G":
			case "H":
			case "I":
			case "J":
			case "K":
			case "L":
			case "M":
			case "N":
			case "O":
			case "P":
			case "Q":
			case "R":
			case "S":
			case "T":
			case "U":
			case "V":
			case "W":
			case "X":
			case "Y":
			case "Z":
			case "⍙":
				switch(state) {
					case "begin":
						state = "name";
						token = "$" + c;
						break;
					case "comment":
					case "quote1":
					case "name":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						state = "name";
						token = c;break;
					}
				break;
			case "0":
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9":
				switch(state) {
					case "begin":
						state = "number";
						token = c;
						break;
					case "negative":
						state = "number";
						token += c;
						break;
					case "decimal":
						state = "fraction";
					case "strand":
						token += c;
						state = "number";
						break;
					case "number":
					case "fraction":
					case "name":
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						state = "number";
						token = c;break;
				}
				break;
			case "¯":
				switch(state) {
					case "begin":
						token = "-";
						state = "negative";
						break;
					case "strand":	
						token += "-";
						state = "negative";
						break;
					case "negative":
					case "number":
					case "decimal":
					case "fraction":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						state = "negative";
						token = "-";break;
				}		
				break;
			case ".":
				switch(state) {
					case "begin":
						tokens.push(["function", c]);
						state = "begin";
						break;
					case "fraction":
					case "negative":
						throw "SYNTAX ERROR";
					case "number":
						state = "decimal";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["function", c]);
						state = "begin";break;
				}
				break;
			case "⍺":
			case "⍵":
			case "⍬":
				switch(state) {
					case "begin":
						tokens.push(["name", ['alpha', 'omega', 'this.empty']["⍺⍵⍬".indexOf(c)]]);break;
					case "negative":
						throw "SYNTAX ERROR";break;
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["name", ['alpha', 'omega', 'empty']["⍺⍵⍬".indexOf(c)]]);
						state = "begin";break;
				}
				break;
			case "'":
				switch(state) {
					case "begin":
						state = "quote1";
						token = "";
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "quote1":
						state = "quote2";
						break;
					case "quote2":
						state = "quote1";
					case "comment":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						state = "quote1";
						token = "";break;
				}
				break;
			case "{":
			case "[":
			case "(":
			case ";":
				switch(state) {
					case "begin":
						tokens.push(["open", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["open", c]);
						state = "begin";break;
				}
				break;
			case "}":
			case "]":
			case ")":
				switch(state) {
					case "begin":
						tokens.push(["close", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["close", c]);
						state = "begin";break;
				}
				break;
			case "⊣":
			case "⌷":
			case "¨":
			case "⍨":
			case "/":
			case "⌿":
			case "\\":
			case "⍀":
			case "<":
			case "≤":
			case "=":
			case "≥":
			case ">":
			case "≠":
			case "∨":
			case "∧":
			case "-":
			case "+":
			case "÷":
			case "×":
			case "?":
			case "∊":
			case "⍴":
			case "~":
			case "↑":
			case "↓":
			case "⍳":
			case "○":
			case "*":
			case "⌈":
			case "⌊":
			case "∇":
			case "∘":
			case "⊂":
			case "⊃":
			case "∩":
			case "∪":
			case "⊥":
			case "⊤":
			case "|":
			case ",":
			case "⍱":
			case "⍲":
			case "⍒":
			case "⍋":
			case "⍉":
			case "⌽":
			case "⊖":
			case "⍟":
			case "⌹":
			case "!":
			case "⍕":
			case "⍎":
			case "⍪":
			case "≡":
			case "≢":
			case "⍷":
				switch(state) {
					case "begin":
						tokens.push(["function", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["function", c]);
						state = "begin";break;
				}
				break;
			case ":":
				switch(state) {
					case "begin":
						tokens.push(["colon", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["colon", c]);
						state = "begin";break;
				}
				break;
			case "⋄":
				switch(state) {
					case "begin":
						tokens.push(["diamond", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["diamond", c]);
						state = "begin";break;
				}
				break;
			case "←":
				switch(state) {
					case "begin":
						tokens.push(["assign", c]);
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						tokens.push(["assign", c]);
						state = "begin";break;
				}
				break;
			case "⍝":
				switch(state) {
					case "begin":
						state = "comment";
						token = "";
						break;
					case "negative":
					case "decimal":
						throw "SYNTAX ERROR";
					case "comment":
					case "quote1":
						token += c;
						break;
					default:
						tokens.push([state, token]);
						state = "comment";
						token = "";
						break;
				}
				break;
			default: 
				switch(state){
					case "comment":
					case "quote2":
						token += c;
						break;
					default:
						throw "SYNTAX ERROR";
				}
			}
		} // end of for loop
		switch(state) {
			case "begin":
				break;
			case "negative":
			case "decimal":
			case "quote1":
				throw "SYNTAX ERROR";
			default:
				tokens.push([state, token]);break;
		}
		return tokens;
	} // end of function
	
	this.compile_monadic = function(funct, right) {
		var script = "";
		for(var n = 0; n < funct.length; n++) {
			var f = funct[n][0]; // function
			if(n === 0) var b = funct[n][1]; // brackets
			script += (n === 0) ? compile_monadic_lookup(f) : compile_dyadic_lookup(f)[0] + ", ";
		}
		script =  script + right ;
		if(b) script += "," + b;
		script += ")";
		return script;
	};

	this.compile_dyadic = function(funct, right, left) {
		var f = funct[0][0];
		var b = funct[0][1];
		if(b) {
			b = "," + b;
		}
		var method = compile_dyadic_lookup(f);
		script = method[0];
		if(method[1]) script = "this.dscalar(" + script + ",";
		else script += "(";
		return script + left + ", " + right + b + ")";
	};

	this.assign = function(right, left) {
		right = clone(right);
		left = left.name;
		return eval(left + " = right"); 
	}
	
	this.dereference = function(right) {
		var n = {};
		n.name = right;
		return n;
	}
	
	this.compile = function(tokens) { // returns [javascript, unused tokens, last element]
		var script = "";
		var state = "begin";
		var pending = []; // holds pending function call which may be multi glyph or dyadic
		var stack = []; // for strands such as (abc)(def) or abc[def][ghi]
		var brackets = ""; // script that holds what's in brackets
		var dfunction = ""; // {}
		mainloop:while(tokens.length !== 0) {
			var t = tokens.pop();
			var type = t[0];
			var element = t[1];
			switch(type) {
				case "comment": 
					break;
				case "quote2":
					var s = "new array(\"char\", [" + element.length + "],[\"" + element + "\".split(\"\")]";
					switch(state) {
						case "begin":
							script = s;
							if(brackets)
								script = "this.index(" + script + "," + brackets + ")";
							break;
						case "value":
							throw "NONCE ERROR";
							break;
						case "function": // left argument
							script = this.compile_dyadic(pending, script, s);
							break;default:break;
					}
					state = "value";
					break;
				case "number":
				case "decimal":
				case "fraction":
					element = "[" + element + "]";
					var l = eval(element).length;
					if(l == 1) l = "";
					var n = "new array(\"numb\", [" + l + "], " + element + ")";
					switch(state) {
						case "begin":
							script = n;
							if(brackets)
								script = "this.index(" + n + "," + brackets + ")";
							break;
						case "value":
							throw "NONCE ERROR";
							break;
						case "function": // left argument
							script = this.compile_dyadic(pending, script, n);
							break;default:break;
					}
					state = "value";
					brackets = "";
					break;
				case "name":
					switch(state) {
						case "begin":
							if(brackets)
								element = "this.index(" + element + "," + brackets + ")";
							script = element;
							break;
						case "value":
							throw "NONCE ERROR";
							break;
						case "function": // left argument
							if(brackets)
								element = "this.index(" + element + "," + brackets + ")";
							script = this.compile_dyadic(pending, script, element);
							break;
						case "assign": 
							// if(brackets) // indexed assignment
								// script = "this.indexassign(" + element + "," + script + "," + brackets + ")";
							// else script = element + " = clone(" + script + ")";  
							script = assign(element, script, brackets);
							break;default:break;
					}
					state = "value";
					brackets = "";
					break;
				case "function": // a function is found
					switch(state) {
						case "begin":
							throw "NONCE ERROR";
						case "value": 
							pending = [[element, brackets]]; // save this function
							state = "function";
							break;
						case "function": // a function is in pending
							switch(pending[0][0]){ // if one of these, operator, otherwise monadic
								case "⌿":
								case "⍀":
								case "/": 
								case "\\":
									pending.push([element, brackets]);
									script = this.compile_monadic(pending, script);
									state = "value";
									break;
								case ".":
									throw "NONCE ERROR";
									pending.push([element, brackets]);
									break;
								default: // monadic, i.e. =-
									script = this.compile_monadic(pending, script);
									pending = [[element, brackets]];break;
								}
							break;default:break;
					}
					brackets = "";
					break;
				case "assign":
					if(brackets) throw "SYNTAX ERROR"; // <-[
					switch(state) {
						case "value":
							break;
						case "function":
							script = this.compile_monadic(pending, script);
							break;default:break;
					}
					state = "assign";
					break;
				case "close": 
				    var open = this.compile(tokens);
					var openscript = open[0];
					tokens = open[1];
					var openelement = open[2];
				    switch(element) {
						case ")":
							if(openelement != "(") throw "SYNTAX ERROR";
							switch(state) {
								case "begin":
									if(brackets)
										openscript = "this.index(" + openscript + "," + brackets + ")";
									script = openscript;
									break;
								case "value":
									throw "NONCE ERROR";
									break;
								case "function": // left argument
									if(brackets)
										openscript = "this.index(" + openscript + "," + brackets + ")";
									script = this.compile_dyadic(pending, script, openscript);
									break;
								case "assign": 
									throw "NONCE ERROR";
								default:break;
							}
							state = "value";
							brackets = "";
							break;
						case "]":
							brackets = openscript + "]";
							switch(openelement) {
								case "[":
									break;
								case ";":
									while(true) {
										open = this.compile(tokens);
										openscript = open[0];
										tokens = open[1];
										openelement = open[2];
										brackets = openscript + "," + brackets;
										if(openelement == "[") break;
										if(openelement != ";") throw "SYNTAX ERROR";
									}
									break;
								default:
									throw "SYNTAX ERROR";
							}
							brackets = "[" + brackets;
							break;
						case "}":
							if(openelement != "{") throw "SYNTAX ERROR";
							throw "NONCE ERROR";
							switch(state) {
								case "begin": // function definition
									script = "(function(omega, alpha){ return " + openscript + ";})";
									state = "value";
									break;
								case "value": // function call
									script = "(function(omega, alpha){ return " + openscript + ";})(" + script;
									state = "dfunctioncall";
									break;
								default:
									throw "NONCE ERROR"; // possible operator
								}
							break;default:break;
					}
					break;
				case "open":  
					break mainloop;default:break;
			} // end of switch(type)
		}  // end of for loop
		switch(state) {
			case "begin":
			case "value":
				break;
			case "function":
				script = this.compile_monadic(pending, script);
				break;
			default:
				throw "SYNTAX ERROR";
		}
		return [script, tokens, element];
	}; // end of compile
	
	this.identity = function(f) { // returns the identity element for scalar functions
		switch(f) {	
			case this.less:         return 0; // left
			case this.lessequal:    return 1; // left
			case this.equal:        return 1; // logical only
			case this.greaterequal: return 1; // right
			case this.greater:      return 0; // right
			case this.notequal:     return 0; // logical only
			case this.or:           return 0;
			case this.and:          return 1;
			case this.minus:        return 0; // right
			case this.add:          return 0;
			case this.divide:       return 1; // right
			case this.multiply:     return 1;
			case this.power:        return 1; // right
			case this.maximum:      return Number.MIN_VALUE;
			case this.minimum:      return Number.MAX_VALUE;
			case this.residue:      return 0; // left
			default:break;
		}
	}; // end of identity
	
	function compile_dyadic_lookup(f) { // returns the name of method for the function
		switch(f) {
			// scalar
			case "<": return ["this.less"    , true];
			case "≤": return ["this.lessequal"   , true];
			case "=": return ["this.equal"       , true];
			case "≥": return ["this.greaterequal", true];
			case ">": return ["this.greater"     , true];
			case "≠": return ["this.notequal"    , true];
			case "∨": return ["this.or"          , true];
			case "∧": return ["this.and"         , true];
			case "-": return ["this.subtract"    , true];
			case "+": return ["this.add"         , true];
			case "÷": return ["this.divide"      , true];
			case "×": return ["this.multiply"    , true];
			case "○": return ["this.circle"      , true];
			case "*": return ["this.power"       , true];
			case "⌈": return ["this.maximum"     , true];
			case "⌊": return ["this.minimum"     , true];
			case "|": return ["this.residue"     , true];
			case "⍱": return ["this.nor"         , true];
			case "⍲": return ["this.nand"        , true];
			// nonscalar
			case "/": return ["this.replicate"   ];
			case "⌿": return ["this.replicate1"  ];
			case "\\": return ["this.expand"     ];
			case "⍀": return ["this.expand1"     ];
			case "?": return ["this.deal"        ];
			case "∊": return ["this.memberof"    ];
			case "⍴": return ["this.reshape"     ];
			case "~": return ["this.exclude"     ];
			case "↑": return ["this.take"        ];
			case "↓": return ["this.drop"        ];
			case "⍳": return ["this.indexof"     ];
			case "⊥": return ["this.decode"      ];
			case "⊤": return ["this.encode"      ];
			case ",": return ["this.catenate"    ];
			case "⍒": return ["this.gradedown"   ];
			case "⍋": return ["this.gradeup"     ];
			case "⍉": return ["this.dtranspose"  ];
			case "⌽": return ["this.rotate"      ];
			case "⊖": return ["this.rotate1"     ];
			case "⍟": return ["this.log"         , true];
			case "!": return ["this.binomial"    ];
			case "⍕": return ["this.dthorn"      ];
			case "⍪": return ["this.catenate1"   ];
			case "≡": return ["this.match"       ];
			case "≢": return ["this.notmatch"    ];
			case "⍨": 
			case "⊣":
			case "⌷":
			case "¨":
			case "⍷":
			case "⍎":
			case "∘":
			case "⌹":
			case "⊂":
			case "⊃":
			case "∩":
			case "∪": throw "NONCE ERROR";default:break;
		}return null;
	} // end of lookup
	
	function compile_monadic_lookup(f) { // returns the name of method for the function
		switch(f) {
			case "/": return "this.reduce(-1,";
			case "⌿": return "this.reduce(0,";
			case "\\": return "this.scan(-1,";
			case "⍀": return "this.scan(0,";
			case "-": return "this.mscalar(this.negate,";
			case "+": return "this.mscalar(this.idem,";
			case "÷": return "this.mscalar(this.reciprocal,";
			case "×": return "this.mscalar(this.signum,";
			case "?": return "this.mscalar(this.roll,";
			case "∊": return "this.type("; 
			case "⍴": return "this.shapeof(";
			case "~": return "this.mscalar(this.not,";
			case "↑": return "this.mix(";
			case "↓": return "this.split(";
			case "⍳": return "this.indexgen(";
			case "○": return "this.mscalar(this.pitimes,";
			case "⌈": return "this.mscalar(this.ceiling,";
			case "⌊": return "this.mscalar(this.floor,";
			case "|": return "this.mscalar(this.magnitude,";
			case ",": return "this.ravel(";
			case "⍒": return "this.gradedown(";
			case "⍋": return "this.gradeup(";
			case "⍉": return "this.transpose(";
			case "⌽": return "this.reverse(-1,";
			case "⊖": return "this.reverse(0,";
			case "!": return "this.factorial(";
			case "⍕": return "this.thorn(";
			case "⍪": return "this.table(";
			case "≡": return "this.depth(";
			case "*": 
			case "⍟": 
			case "⊣":
			case "⌷":
			case "¨":
			case "⍷":
			case "⍎":
			case "∘":
			case "⌹":
			case "⊂":
			case "⊃":
			case "∩":
			case "∪": throw "NONCE ERROR";default:break;
		}return null;
	} // end of lookup

	this.tryexecute = function(xpr) {
		//throw "stop here";
		var tok = this.tokenize(xpr);
		var scr = this.compile(tok)[0];
		//document.write(scr + "<br>");
		document.write("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + xpr + "<br>");
		var a;
		try {
			a = eval(scr);
			a = this.toHTML(a);
		} catch (err) {
			a = err;
		}
		document.write(a + "<br>");
	};
	
	this.execute = function(xpr) {
		//throw "stop here";
		var tok = this.tokenize(xpr);
		var scr = this.compile(tok)[0];
		//document.write(scr + "<br>");
		document.write("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + xpr + "<br>");
		var a;
		try {
			a = eval(scr);
			a = this.toHTML(a);
		} catch (err) {
			a = err;
		}
		document.write(a + "<br>");
	};
	
	this.evaluate = function(script) {
		return eval(script);
	}

	this.definexq = function(script) {
		var xq = "";
		for(var n = 0; n < script.length; n++) {
			xq += "try{output.push([true, toThorn(" + script[n] + ")]);}catch(err){output.push([false, err + \"<br>\"]);}";
		}
		eval("this.xq = function(context){with(context) {var output = [];" + xq + "return output;}};");
		return this.xq;
	}
	
} // end of class

// test
// with(new apl()) {
	// document.write("<div>");
	// var xq = "var output = [];";
	// for(var n = 0; n < testscript.length; n++) {
		// //tryexecute(testscript[n]);
		// xq += "try{output.push(this.toHTML(" + compile(tokenize(testscript[n]))[0] + "))}catch(err){output.push(err + \"<br>\");}\r\n";
	// }
	// var fn = evaluate("this.fn = function(){" + xq + "return output;};");
	// var start = (new Date()).getTime();
	// var out = fn();
	// var end = (new Date()).getTime();
	// var diff = end - start;
	// document.write(diff + " milliseconds <br>");
	// for(var n = 0; n < testscript.length; n++) {
		// document.write("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + testscript[n] + "<br>");
		// document.write(out[n]);
	// }
	// // -------------------------------------------------------------------------------------
	// // to do:
	
	// document.write("</div>");
//}
